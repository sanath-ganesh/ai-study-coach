---chunk-0---
Lecture 29: Faster Sorting Methods - 2 Materials are edited by Prof. Jones Yu fromData Structures and Abstractions with Java, 5th edition. By Frank M. Carrano and Timothy M. Henry. ISBN-13 978-0-13-483169-5 © 2019 Pearson Education, Inc. Prof. Chen-Hsiang (Jones) Yu, Ph.D.College of Engineering Quick Sort 3INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §Divides an array into two pieces−Pieces are not necessarily halves of the array−Chooses one entry in the array - called the pivot§Partitions the array Quick Sort 4INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §When pivot is chosen, array rearranged such that:−Pivot is in position that it will occupy in final sorted array−Entries in positions before pivot are less than or equal to pivot−Entries in positions after pivot are greater than or equal to pivot Quick Sort 5INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Algorithm that describes our sorting strategy Quick SortAlgorithm quicksort(a, first, last)// Sorts the array entries a[first..last] recursively.if (first < last){ Choose a pivot Partition the array about the pivot pivotIndex= index of pivotquickSort(a, first, pivotIndex− 1) // Sort SmallerquickSort(a, pivotIndex+ 1, last) //Sort Larger} 6INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-5: A partition of an array during a quick sort Quick Sort §Quick sort: O(n log n) in average case, O(n2) in worst case. §Choice of pivots affects behavior 7INFO 6205 -ProgramStructureand AlgorithmsFall 2024Figure 16-6: A partitioning strategy for quick sort Creating the Partition After choosing a pivot, swap it with the last entry in the array Pivot-selection strategy 8INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-6: A partitioning strategy for quick sort Creating the Partition 9INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-6: A partitioning strategy for quick sort Creating the Partition 10INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-7: Median-of-three pivot selection: (a) The original array; (b) the array with its first, middle, and last entries sorted Pivot Selection 11INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-8: (a) The array with its first, middle, and last entries sorted; (b) the array after positioning the pivot and just before partitioning Adjusting the Partition Algorithm 12INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Adjusting the Partition AlgorithmAlgorithm partition(a, first, last)// Partitions an array a[first..last] as part of quick sort into two subarrays named // Smaller and Larger that are separated by a single entry -- the pivot -- named pivotValue. // Entries in Smaller are <= pivotValue and appear before pivotValue in the array. // Entries in Larger are >= pivotValue and appear after pivotValue in the array. // Precondition: first >= 0; first < a.length; last – first >= 3; last < a.length. // Returns the index of the pivot. mid = index of the array’s middle entrysortFirstMiddleLast(a, first, mid, last)// Assertion: a[mid] is the pivot, that is, pivotValue; // a[first] <= pivotValue and a[last] >= pivotValue, so do not compare these two // array entries with pivotValue. // Move pivotValue to next-to-last position in array Exchange a[mid] and a[last – 1]pivotIndex= last –1 pivotValue= a[pivotIndex] // Determine two subarrays: // Smaller = a[first..endSmaller] and // Larger = a[endSmaller+1..last–1] // such that entries in Smaller are <= pivotValue and entries in Larger are >= pivotValue. // Initially, these subarrays are empty.indexFromLeft= first + 1 indexFromRight= last − 2done = falsewhile (!done){ // Starting at the beginning of the array, leave entries that are < pivotValueand // locate the first entry that is >= pivotValue. You will find one, since the last // entry is >= pivotValue. while (a[indexFromLeft]<pivotValue) indexFromLeft++ // Starting at the end of the array, leave entries that are > pivotValueand // locate the first entry that is <= pivotValue. You will find one, since the first // entry is <= pivotValue. while (a[indexFromRight]>pivotValue) indexFromRight−− // Assertion: a[indexFromLeft] >= pivotValue and a[indexFromRight] <= pivotValue if (indexFromLeft< indexFromRight) { Exchange a[indexFromLeft] and a[indexFromRight] indexFromLeft++ indexFromRight−− } else { done = true }} // end of while// Place pivotValue between the subarrays Smaller and LargerExchange a[pivotIndex] and a[indexFromLeft] pivotIndex = indexFromLeft// Assertion: Smaller = a[first..pivotIndex–1], pivotValue=a[pivotIndex], Larger =a[pivotIndex+1..last]return pivotIndex 15INFO 6205 -ProgramStructureand AlgorithmsFall 2024Above method implements quick sort The Quick Sort Methodpublicstatic<T extendsComparable<? superT>>voidquickSort(T[] a, intfirst, intlast){if(last -first + 1< MIN_SIZE){insertionSort(a, first, last);}else{// Create the partition: Smaller | Pivot | LargerintpivotIndex= partition(a, first, last);// Sort subarrays Smaller and LargerquickSort(a, first, pivotIndex-1);quickSort(a, pivotIndex+ 1, last);} // end if} // end quickSort 16INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Class Arrays in the package java.util uses a quick sort to sort arrays of primitive types into ascending order Quick Sort in the Java Class Library publicstaticvoidsort(type[] a)publicstaticvoidsort(type[] a, intfirst, intafter) 17INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §Trace the steps that the method quickSort takes when sorting the following array into ascending order. Assume that MIN_SIZE = 4 9 6 2 4 8 7 5 3 Exercise Answer Radix Sort 20INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §Does not use comparison§Treats array entries as if they were strings that have the same length.−Group integers according to their rightmost character (digit) into “buckets”−Repeat with next character (digit), etc.§It is not suitable as a general-purpose sorting algorithm. Radix Sort 21INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (a) Original array and buckets after first distribution; Radix Sort Rightmost digit is 0Rightmost digit is 9 22INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (b) reordered array and buckets after second distribution Radix Sort 23INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (c) reordered array and buckets after third distribution; (d) sorted array Radix Sort 24INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Radix sort is an O(n) algorithm for certain data, it is not appropriate for all data Pseudocode for Radix Sort 25INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-10: The time efficiency of various sorting algorithms, expressed in Big Oh notation Comparing the AlgorithmsBest CaseAverage CaseWorst CaseRadix SortO(n) O(n) O(n)Merge SortO(n logn) O(n logn) O(n logn)Quick SortO(n logn) O(n logn) O(n2)Shell SortO(n) O(n1.5) O(n1.5)Insertion SortO(n) O(n2) O(n2)Selection SortO(n2) O(n2) O(n2) 26INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B.§Write a method to merge B into A in sorted order.
---chunk-1---
according to their rightmost character (digit) into “buckets”−Repeat with next character (digit), etc.§It is not suitable as a general-purpose sorting algorithm. Radix Sort 21INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (a) Original array and buckets after first distribution; Radix Sort Rightmost digit is 0Rightmost digit is 9 22INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (b) reordered array and buckets after second distribution Radix Sort 23INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-9: Radix sort: (c) reordered array and buckets after third distribution; (d) sorted array Radix Sort 24INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Radix sort is an O(n) algorithm for certain data, it is not appropriate for all data Pseudocode for Radix Sort 25INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Figure 16-10: The time efficiency of various sorting algorithms, expressed in Big Oh notation Comparing the AlgorithmsBest CaseAverage CaseWorst CaseRadix SortO(n) O(n) O(n)Merge SortO(n logn) O(n logn) O(n logn)Quick SortO(n logn) O(n logn) O(n2)Shell SortO(n) O(n1.5) O(n1.5)Insertion SortO(n) O(n2) O(n2)Selection SortO(n2) O(n2) O(n2) 26INFO 6205 -ProgramStructureand AlgorithmsFall 2024 §You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B.§Write a method to merge B into A in sorted order. Exercise 27INFO 6205 -ProgramStructureand AlgorithmsFall 2024 AnswerpublicstaticvoidmergeArrays(int[] a, int[] b, intnumA, intnumB) {intnewLastIndex= numA+ numB-1;intlastIndexA= numA-1;intlastIndexB= numB-1;intloop= numA>= numB? numB: numA;for(inti= loop; i>= 0; i--) {if(a[lastIndexA] > b[lastIndexB]) {a[newLastIndex] = a[lastIndexA];lastIndexA--;} else{a[newLastIndex] = b[lastIndexB];lastIndexB--;}newLastIndex--;}//Copy remaining elements of a or b to array aif(loop== numA) {for(intj= lastIndexB; j>= 0; j--) {a[newLastIndex] = b[j];newLastIndex--;}}else{for(intj= lastIndexA; j>= 0; j--) {a[newLastIndex] = a[j];newLastIndex--;}}}
