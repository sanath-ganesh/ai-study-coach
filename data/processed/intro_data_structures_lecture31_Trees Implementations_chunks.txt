---chunk-0---
Lecture 31: Trees Implementation Materials are edited by Prof. Jones Yu fromData Structures and Abstractions with Java, 5th edition. By Frank M. Carrano and Timothy M. Henry. ISBN-13 978-0-13-483169-5 © 2019 Pearson Education, Inc. Prof. Chen-Hsiang (Jones) Yu, Ph.D.College of Engineering 2INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Node in a Binary Tree A node in a binary tree 3INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Binary Tree Node - 1 The class BinaryNode packageTreePackage;/**A class that represents nodes in a binary tree.*/classBinaryNode<T>{privateT data;privateBinaryNode<T> leftChild; // Reference to left childprivateBinaryNode<T> rightChild; // Reference to right childpublicBinaryNode(){this(null); // Call next constructor} // end default constructorpublicBinaryNode(T dataPortion){this(dataPortion, null, null); // Call next constructor} // end constructorpublicBinaryNode(T dataPortion, BinaryNode<T> newLeftChild,BinaryNode<T> newRightChild){data = dataPortion;leftChild= newLeftChild;rightChild= newRightChild;} // end constructor 4INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Binary Tree Node - 2/** Retrieves the data portion of this node.@returnThe object in the data portion of the node. */publicT getData(). {returndata;} // end getData/** Sets the data portion of this node.@paramnewDataThe data object. */publicvoidsetData(T newData){data = newData;} // end setData/** Retrieves the left child of this node.@returnA reference to this node's left child. */publicBinaryNode<T> getLeftChild(){returnleftChild;} // end getLeftChild/** Sets this node’s left child to a given node.@paramnewLeftChildA node that will be the left child. */publicvoidsetLeftChild(BinaryNode<T> newLeftChild){leftChild= newLeftChild;} // end setLeftChildThe class BinaryNode 5INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Binary Tree Node - 3/** Detects whether this node has a left child.@returnTrue if the node has a left child. */publicbooleanhasLeftChild(){returnleftChild!= null;} // end hasLeftChild /* Implementations of getRightChild, setRightChild, and hasRightChildare here and are analogous to their left-child counterparts. *//** Detects whether this node is a leaf.@returnTrue if the node is a leaf. */publicbooleanisLeaf(){return(leftChild== null) && (rightChild== null);} // end isLeaf/** Counts the nodes in the subtree rooted at this node.@returnThe number of nodes in the subtree rooted at this node. */publicintgetNumberOfNodes(){// < Coming later ——See Segment 25.10. >} // end getNumberOfNodesThe class BinaryNode 6INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Binary Tree Node - 4 /** Computes the height of the subtree rooted at this node.@returnThe height of the subtree rooted at this node. */publicintgetHeight(){// < Coming later —-See Segment 25.10. >} // end getHeight/** Copies the subtree rooted at this node.@returnThe root of a copy of the subtree rooted at this node. */publicBinaryNode<T> copy(){// < Coming later ——See Segment 25.5. >} // end copy} // end BinaryNode The class BinaryNode 7INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Interface for a Basic Binary Tree Interface for a class of binary trees packageTreePackage;/**An interface for the ADT binary tree.*/publicinterfaceBinaryTreeInterface<T> extendsTreeInterface<T>, TreeIteratorInterface<T>{/** Sets the data in the root of this binary tree.@paramrootDataThe object that is the data for the tree's root.*/publicvoidsetRootData(T rootData);/** Sets this binary tree to a new binary tree.@paramrootDataThe object that is the data for the new tree's root.@paramleftTreeThe left subtree of the new tree.@paramrightTreeThe right subtree of the new tree. */publicvoidsetTree(T rootData, BinaryTreeInterface<T> leftTree,BinaryTreeInterface<T> rightTree);} // end BinaryTreeInterface 8INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Creating a Basic Binary Tree - 1 A first draft of the class BinaryTree packageTreePackage;importjava.util.Iterator;importjava.util.NoSuchElementException;importStackAndQueuePackage.*; // Needed by tree iterators/**A class that implements the ADT binary tree.*/publicclassBinaryTree<T> implementsBinaryTreeInterface<T>{privateBinaryNode<T> root;publicBinaryTree(){root = null;} // end default constructorpublicBinaryTree(T rootData){root = newBinaryNode<>(rootData);} // end constructorpublicBinaryTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree){initializeTree(rootData, leftTree, rightTree);} // end constructor 9INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Creating a Basic Binary Tree - 2publicvoidsetTree(T rootData, BinaryTreeInterface<T> leftTree,BinaryTreeInterface<T> rightTree){initializeTree(rootData, (BinaryTree<T>)leftTree,(BinaryTree<T>)rightTree);} // end setTreeprivatevoidinitializeTree(T rootData, BinaryTree<T> leftTree,BinaryTree<T> rightTree){// < FIRST DRAFT -See Segments 25.4 -25.7 for improvements. >root = newBinaryNode<T>(rootData);if(leftTree!= null)root.setLeftChild(leftTree.root);if(rightTree!= null)root.setRightChild(rightTree.root);} // end initializeTree /* Implementations of setRootData, getRootData, getHeight, getNumberOfNodes,isEmpty, clear, and the methods specified in TreeIteratorInterfaceare here.. . . */} // end BinaryTreeA first draft of the class BinaryTree 10INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Creating a Binary Tree The binary tree treeA shares nodes with treeB and treeC treeA.setTree(a, treeB, treeC); 11INFO 6205 -ProgramStructureand AlgorithmsFall 2024 The Method copy Definition of the method copy in the class BinaryNode /** Copies the subtree rooted at this node.*/publicBinaryNode<T> copy(){BinaryNode<T> newRoot= newBinaryNode<>(data);if(leftChild!= null)newRoot.setLeftChild(leftChild.copy());if(rightChild!= null)newRoot.setRightChild(rightChild.copy());returnnewRoot;} // end copy 12INFO 6205 -ProgramStructureand AlgorithmsFall 2024 The Method initializeTree Definition of the method copy in the class BinaryNode privatevoidinitializeTree(T rootData, BinaryTree<T> leftTree,BinaryTree<T> rightTree){root = newBinaryNode<>(rootData);if((leftTree!= null) && !leftTree.isEmpty())root.setLeftChild(leftTree.root.copy());if((rightTree!= null) && !rightTree.isEmpty())root.setRightChild(rightTree.root.copy());} // end initializeTree 13INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Additional Challenges treeA has identical subtrees 14INFO 6205 -ProgramStructureand AlgorithmsFall 2024 treeA has identical subtrees Method initializeTree Solution §If left subtree exists and not empty, −attach root node to r as left child.§Create root node r containing given data.§If right subtree exists, not empty, and distinct from left subtree, −attach root node to r as a right child. §But if right and left subtrees are same, −attach copy of right subtree to r instead.§If the left subtree exists and differs from the tree object used to call initializeTree, −set the subtree’s data field root to null.§If right subtree exists and differs from the tree object used to call initializeTree, −set subtree’s data field root to null. 15INFO 6205 -ProgramStructureand AlgorithmsFall 2024An implementation of initializeTree Method initializeTree Solution (cont.) privatevoidinitializeTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree){ root = newBinaryNode<>(rootData);if((leftTree!= null) && !leftTree.isEmpty())root.setLeftChild(leftTree.root);if((rightTree!= null) && !rightTree.isEmpty()){if(rightTree!= leftTree)root.setRightChild(rightTree.root);elseroot.setRightChild(rightTree.root.copy());} // end ifif((leftTree!= null) && (leftTree!= this))leftTree.clear();if((rightTree!= null) && (rightTree!= this))rightTree.clear();} // end initializeTree 16INFO 6205 -ProgramStructureand AlgorithmsFall 2024 BinaryTree Accessor and Mutator MethodspublicvoidsetRootData(T rootData){root.setData(rootData);} // end setRootDatapublicT getRootData(){if(isEmpty())thrownewEmptyTreeException();elsereturnroot.getData();} // end getRootDataprotectedvoidsetRootNode(BinaryNode<T> rootNode){root = rootNode;} // end setRootNodeprotectedBinaryNode<T> getRootNode(){returnroot;} // end getRootNode 17INFO 6205 -ProgramStructureand AlgorithmsFall 2024 More BinaryTree MethodspublicintgetHeight(){intheight = 0;if(root != null)height = root.getHeight();returnheight;} // end getHeightpublicintgetNumberOfNodes(){intnumberOfNodes= 0;if(root != null)numberOfNodes= root.getNumberOfNodes();returnnumberOfNodes;} // end getNumberOfNodes Computing the Height and Counting Nodes 18INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Methods within BinaryNode - 1 publicintgetHeight(){returngetHeight(this); // Call private getHeight} // end getHeightprivateintgetHeight(BinaryNode<T> node){intheight = 0;if(node != null)height = 1+ Math.max(getHeight(node.getLeftChild()),getHeight(node.getRightChild()));returnheight;} 19INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Methods within BinaryNode - 2 publicintgetNumberOfNodes(){intleftNumber= 0;intrightNumber= 0;if(left != null)leftNumber= left.getNumberOfNodes();if(right != null)rightNumber= right.getNumberOfNodes();return1+ leftNumber+ rightNumber;} // end getNumberOfNodes 20INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Traversing a binary tree recursivelypublicvoidinorderTraverse(){inorderTraverse(root);} // end inorderTraverseprivatevoidinorderTraverse(BinaryNode<T> node){if(node != null){inorderTraverse(node.getLeftChild());System.out.println(node.getData());inorderTraverse(node.getRightChild());} // end if} // end inorderTraverse A binary tree 21INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Non-recursive Traversal - 1 Using a stack to perform an in-order traversal of a binary
---chunk-1---
data field root to null. 15INFO 6205 -ProgramStructureand AlgorithmsFall 2024An implementation of initializeTree Method initializeTree Solution (cont.) privatevoidinitializeTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree){ root = newBinaryNode<>(rootData);if((leftTree!= null) && !leftTree.isEmpty())root.setLeftChild(leftTree.root);if((rightTree!= null) && !rightTree.isEmpty()){if(rightTree!= leftTree)root.setRightChild(rightTree.root);elseroot.setRightChild(rightTree.root.copy());} // end ifif((leftTree!= null) && (leftTree!= this))leftTree.clear();if((rightTree!= null) && (rightTree!= this))rightTree.clear();} // end initializeTree 16INFO 6205 -ProgramStructureand AlgorithmsFall 2024 BinaryTree Accessor and Mutator MethodspublicvoidsetRootData(T rootData){root.setData(rootData);} // end setRootDatapublicT getRootData(){if(isEmpty())thrownewEmptyTreeException();elsereturnroot.getData();} // end getRootDataprotectedvoidsetRootNode(BinaryNode<T> rootNode){root = rootNode;} // end setRootNodeprotectedBinaryNode<T> getRootNode(){returnroot;} // end getRootNode 17INFO 6205 -ProgramStructureand AlgorithmsFall 2024 More BinaryTree MethodspublicintgetHeight(){intheight = 0;if(root != null)height = root.getHeight();returnheight;} // end getHeightpublicintgetNumberOfNodes(){intnumberOfNodes= 0;if(root != null)numberOfNodes= root.getNumberOfNodes();returnnumberOfNodes;} // end getNumberOfNodes Computing the Height and Counting Nodes 18INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Methods within BinaryNode - 1 publicintgetHeight(){returngetHeight(this); // Call private getHeight} // end getHeightprivateintgetHeight(BinaryNode<T> node){intheight = 0;if(node != null)height = 1+ Math.max(getHeight(node.getLeftChild()),getHeight(node.getRightChild()));returnheight;} 19INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Methods within BinaryNode - 2 publicintgetNumberOfNodes(){intleftNumber= 0;intrightNumber= 0;if(left != null)leftNumber= left.getNumberOfNodes();if(right != null)rightNumber= right.getNumberOfNodes();return1+ leftNumber+ rightNumber;} // end getNumberOfNodes 20INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Traversing a binary tree recursivelypublicvoidinorderTraverse(){inorderTraverse(root);} // end inorderTraverseprivatevoidinorderTraverse(BinaryNode<T> node){if(node != null){inorderTraverse(node.getLeftChild());System.out.println(node.getData());inorderTraverse(node.getRightChild());} // end if} // end inorderTraverse A binary tree 21INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Non-recursive Traversal - 1 Using a stack to perform an in-order traversal of a binary tree 22INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Non-recursive Traversal - 2publicvoiditerativeInorderTraverse(){StackInterface<BinaryNode<T>> nodeStack= newLinkedStack<>();BinaryNode<T> currentNode= root;while(!nodeStack.isEmpty() || (currentNode!= null)){// Find leftmost node with no left childwhile(currentNode!= null){nodeStack.push(currentNode);currentNode= currentNode.getLeftChild();} // end while// Visit leftmost node, then traverse its right subtreeif(!nodeStack.isEmpty()){BinaryNode<T> nextNode= nodeStack.pop();// Assertion: nextNode!= null, since nodeStackwas not empty// before the popSystem.out.println(nextNode.getData());currentNode= nextNode.getRightChild();} // end if} // end while} // end iterativeInorderTraverse 23INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Traversals That Use An Iterator - 1privateclassInorderIteratorimplementsIterator<T>{privateStackInterface<BinaryNode<T>> nodeStack;privateBinaryNode<T> currentNode;publicInorderIterator(){nodeStack= newLinkedStack<>();currentNode= root;} // end default constructorpublicvoidremove(){thrownewUnsupportedOperationException();} // end removepublicbooleanhasNext() {return!nodeStack.isEmpty() || (currentNode!= null);} // end hasNext The private inner class InorderIterator 24INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Traversals That Use An Iterator - 2publicT next(){BinaryNode<T> nextNode= null;// Find leftmost node with no left childwhile(currentNode!= null){nodeStack.push(currentNode);currentNode= currentNode.getLeftChild();} // end while// Get leftmost node, then move to its right subtreeif(!nodeStack.isEmpty()){nextNode= nodeStack.pop();// Assertion: nextNode!= null, since nodeStackwas not empty// before the popcurrentNode= nextNode.getRightChild();}elsethrownewNoSuchElementException();returnnextNode.getData(); } // end next} // end InorderIteratorThe private inner class InorderIterator 25INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Using a Stack to Traverse a Binary Tree Using a stack to traverse a binary tree in preorder and postorder 26INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Using a Queue for Level-Order Traversal Using a queue to traverse a binary tree in level order 27INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Implementation of an Expression Tree - 1 An interface for an expression tree packageTreePackage;/**An interface for an expression tree.*/publicinterfaceExpressionTreeInterfaceextendsBinaryTreeInterface<String>{/** Computes the value of the expression in this tree.@returnThe value of the expression. */publicdoubleevaluate();} // end ExpressionTreeInterface 28INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Implementation of an Expression Tree - 2 The class ExpressionTree packageTreePackage;/**A class that implements an expression tree by extending BinaryTree.*/publicclassExpressionTreeextendsBinaryTree<String>implementsExpressionTreeInterface{publicExpressionTree(){} // end default constructorpublicdoubleevaluate(){returnevaluate(getRootNode());} // end evaluateprivatedoublegetValueOf(String variable){ // Strings allow multicharacter variablesdoubleresult = 0;// To be defined. returnresult;} // end getValueOf 29INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Implementation of an Expression Tree - 3private double compute(String operator, double firstOperand, double secondOperand) { double result = 0; // To be defined. return result; } // end compute private double evaluate(BinaryNode<String> rootNode) { double result; if (rootNode == null) result = 0; else if (rootNode.isLeaf()) { String variable = rootNode.getData(); result = getValueOf(variable); } else { double firstOperand = evaluate(rootNode.getLeftChild()); double secondOperand = evaluate(rootNode.getRightChild()); String operator = rootNode.getData(); result = compute(operator, firstOperand, secondOperand); } // end if return result; } // end evaluate} // end ExpressionTreeThe class ExpressionTree 30INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Representing General Trees A node for a general tree 31INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Representing General Trees (cont.) An interface for a node in a general tree packageTreePackage;importjava.util.Iterator;/**An interface for a node in a general tree.*/interfaceGeneralNodeInterface<T>{publicT getData();publicvoidsetData(T newData);publicbooleanisLeaf();publicIterator<GeneralNodeInterface<T>> getChildrenIterator();publicvoidaddChild(GeneralNodeInterface<T> newChild);} // end GeneralNodeInterface 32INFO 6205 -ProgramStructureand AlgorithmsFall 2024 Representing General Trees (cont.) A general tree and two views of an equivalent binary tree
